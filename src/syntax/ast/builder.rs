//! Defines an interfaces to receive parse data and construct ASTs.
//!
//! This allows the parser to remain agnostic of the required source
//! representation, and frees up the library user to substitute their own.
//! If one does not require a custom AST representation, this module offers
//! a reasonable default builder implementation.

use syntax::ast::{self, Command, CompoundCommand, SimpleCommand, Redirect, Word};

/// An indicator to the builder of how complete commands are separated.
#[derive(Debug, PartialEq, Eq)]
pub enum SeparatorKind {
    /// A semicolon appears between commands, normally indicating a sequence.
    Semi,
    /// An ampersand appears between commands, normally indicating an asyncronous job.
    Amp,
    /// A newline (and possibly a comment) appears at the end of a command before the next.
    Newline(ast::Newline),
    /// The command was delimited by a token (e.g. a compound command delimiter) or
    /// the end of input, but is *not* followed by another sequential command.
    Other,
}

/// An indicator to the builder whether an `AND` or `OR` command was parsed.
#[derive(Debug, PartialEq, Eq)]
pub enum AndOrKind {
    /// An `AND` command was parsed, normally indicating the second should run if the first succeeds.
    /// Corresponds to the `&&` command separator.
    And,
    /// An `OR` command was parsed, normally indicating the second should run if the first fails.
    /// Corresponds to the `||` command separator.
    Or,
}

/// An indicator to the builder whether a `while` or `until` command was parsed.
#[derive(Debug, PartialEq, Eq)]
pub enum LoopKind {
    /// A `while` command was parsed, normally indicating the loop's body should be run
    /// while the guard's exit status is successful.
    While,
    /// An `until` command was parsed, normally indicating the loop's body should be run
    /// until the guard's exit status becomes successful.
    Until,
}

/// A `Builder` implementation which builds shell commands using the AST definitions in the `ast` module.
pub struct CommandBuilder;

/// A trait which defines an interface which the parser defined in the `parse` module
/// uses to delegate Abstract Syntax Tree creation. The methods defined here correspond
/// to their respectively named methods on the parser, and accept the relevant data for
/// each shell command type.
pub trait Builder {
    /// The type which represents the different shell commands.
    type Output;
    /// An error type that the builder may want to return.
    type Err;

    /// Invoked once a complete command is found. That is, a command delimited by a
    /// newline, semicolon, ampersand, or the end of input.
    ///
    /// # Arguments
    /// * separator: indicates how the command was delimited
    /// * cmd: the command itself, previously generated by the same builder
    fn complete_command(&mut self,
                        separator: SeparatorKind,
                        cmd: Self::Output)
        -> Result<Self::Output, Self::Err>;

    /// Invoked once two pipeline commands are parsed, which are separated by '&&' or '||'.
    /// Typically the second command is run based on the exit status of the first, running
    /// if the first succeeds for an AND command, or if the first fails for an OR command.
    ///
    /// # Arguments
    /// * kind: the type of command parsed, AND or OR
    /// * first: the command on the left side of the separator
    /// * second: the command on the right side of the separator
    fn and_or(&mut self,
              kind: AndOrKind,
              first: Self::Output,
              second: Self::Output)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when a pipeline of commands is parsed.
    /// A pipeline is one or more commands where the standard output of the previous
    /// typically becomes the standard input of the next.
    ///
    /// # Arguments
    /// bang: the presence of a `!` at the start of the pipeline, typically indicating
    /// that the pipeline's exit status should be logically inverted.
    /// cmds: the commands that make up the pipeline in the order they were parsed
    fn pipeline(&mut self,
                bang: bool,
                cmds: Vec<Self::Output>)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when the "simplest" possible command is parsed: an executable with arguments.
    ///
    /// # Arguments
    /// * env_vars: environment variables to be defined only for the command before it is run.
    /// * cmd: the name of the command to be run. This value is optional since the shell grammar
    /// permits that a simple command be made up of only env var definitions or redirections (or both).
    /// * args: arguments to the command
    /// * redirections: redirection of any file descriptors to/from other file descriptors or files.
    fn simple_command(&mut self,
                      env_vars: Vec<(String, Word)>,
                      cmd: Option<Word>,
                      args: Vec<Word>,
                      redirections: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when a non-zero number of commands were parsed between balanced curly braces.
    /// Typically these commands should run within the current shell environment.
    ///
    /// # Arguments
    /// * cmds: the commands that were parsed between braces
    /// * redirects: any redirections to be applied over the **entire** group of commands
    fn brace_group(&mut self,
                   cmds: Vec<Self::Output>,
                   redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when a non-zero number of commands were parsed between balanced parentheses.
    /// Typically these commands should run within their own environment without affecting
    /// the shell's global environment.
    ///
    /// # Arguments
    /// * cmds: the commands that were parsed between parens
    /// * redirects: any redirections to be applied over the **entire** group of commands
    fn subshell(&mut self,
                cmds: Vec<Self::Output>,
                redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when a loop command like `while` or `until` is parsed.
    /// Typically these commands will execute their body based on the exit status of their guard.
    ///
    /// # Arguments
    /// * kind: the type of the loop: `while` or `until`
    /// * guard: commands that determine how long the loop will run for
    /// * body: commands to be run every iteration of the loop
    /// * redirects: any redirections to be applied over **all** commands part of the loop
    fn loop_command(&mut self,
                    kind: LoopKind,
                    guard: Vec<Self::Output>,
                    body: Vec<Self::Output>,
                    redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when an `if` conditional command is parsed.
    /// Typically an `if` command is made up of one or more guard-body pairs, where the body
    /// of the first successful corresponding guard is executed. There can also be an optional
    /// `else` part to be run if no guard is successful.
    ///
    /// # Arguments
    /// branches: a collection of (guard, body) command groups
    /// else_part: optional group of commands to be run if no guard exited successfully
    /// * redirects: any redirections to be applied over **all** commands within the `if` command
    fn if_command(&mut self,
                  branches: Vec<(Vec<Self::Output>, Vec<Self::Output>)>,
                  else_part: Option<Vec<Self::Output>>,
                  redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when a `for` command is parsed.
    /// Typically a `for` command binds a variable to each member in a group of words and
    /// invokes its body with that variable present in the environment. If no words are
    /// specified, the command will iterate over the arguments to the script or enclosing function.
    ///
    /// # Arguments
    /// var: the name of the variable to which each of the words will be bound
    /// in_words: a group of words to iterate over if present
    /// body: the body to be invoked for every iteration
    /// * redirects: any redirections to be applied over **all** commands within the `for` command
    fn for_command(&mut self,
                   var: String,
                   in_words: Option<Vec<Word>>,
                   body: Vec<Self::Output>,
                   redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when a `case` command is parsed.
    /// Typically this command will execute certain commands when a given word matches a pattern.
    ///
    /// # Arguments
    /// * word: the word to be matched against
    /// * arms: the various alternatives that the `case` command can take. The first part of the tuple
    /// is a list of alternative patterns which correspond to a group of commands to be run in case
    /// any of the alternative patterns is matched.
    /// * redirects: any redirections to be applied over **all** commands part of the `case` block
    fn case_command(&mut self,
                    word: Word,
                    arms: Vec<(Vec<Word>, Vec<Self::Output>)>,
                    redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>;

    /// Invoked when a function declaration is parsed.
    /// Typically a function declaration overwrites any previously defined function
    /// within the current environment.
    ///
    /// # Arguments
    /// * name: the name of the function to be created
    /// * body: commands to be run when the function is invoked
    fn function_declaration(&mut self,
                            name: String,
                            body: Self::Output)
        -> Result<Self::Output, Self::Err>;
}

impl Builder for CommandBuilder {
    type Output = Command;
    type Err = ();

    fn complete_command(&mut self,
                        separator: SeparatorKind,
                        cmd: Self::Output)
        -> Result<Self::Output, Self::Err>
    {
        match separator {
            SeparatorKind::Semi  |
            SeparatorKind::Other |
            SeparatorKind::Newline(_) => Ok(cmd),
            SeparatorKind::Amp => Ok(Command::Job(Box::new(cmd))),
        }
    }

    fn and_or(&mut self,
              kind: AndOrKind,
              first: Self::Output,
              second: Self::Output)
        -> Result<Self::Output, Self::Err>
    {
        match kind {
            AndOrKind::And => Ok(Command::And(Box::new(first), Box::new(second))),
            AndOrKind::Or  => Ok(Command::Or(Box::new(first), Box::new(second))),
        }
    }

    fn pipeline(&mut self,
                bang: bool,
                mut cmds: Vec<Self::Output>)
        -> Result<Self::Output, Self::Err>
    {
        debug_assert_eq!(cmds.is_empty(), false);
        cmds.shrink_to_fit();

        // Command::Pipe is the only AST node which allows for a status
        // negation, so we are forced to use it even if we have a single
        // command. Otherwise there is no need to wrap it further.
        if bang || cmds.len() > 1 {
            Ok(Command::Pipe(bang, cmds))
        } else {
            Ok(cmds.pop().unwrap())
        }
    }

    fn simple_command(&mut self,
                      mut env_vars: Vec<(String, Word)>,
                      cmd: Option<Word>,
                      mut args: Vec<Word>,
                      mut redirections: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>
    {
        env_vars.shrink_to_fit();
        args.shrink_to_fit();
        redirections.shrink_to_fit();

        Ok(Command::Simple(Box::new(SimpleCommand {
            cmd: cmd,
            vars: env_vars,
            args: args,
            io: redirections,
        })))
    }

    fn brace_group(&mut self,
                   mut cmds: Vec<Self::Output>,
                   mut redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>
    {
        cmds.shrink_to_fit();
        redirects.shrink_to_fit();
        Ok(Command::Compound(Box::new(CompoundCommand::Brace(cmds)), redirects))
    }

    fn subshell(&mut self,
                mut cmds: Vec<Self::Output>,
                mut redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>
    {
        cmds.shrink_to_fit();
        redirects.shrink_to_fit();
        Ok(Command::Compound(Box::new(CompoundCommand::Subshell(cmds)), redirects))
    }

    fn loop_command(&mut self,
                    kind: LoopKind,
                    mut guard: Vec<Self::Output>,
                    mut body: Vec<Self::Output>,
                    mut redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>
    {
        guard.shrink_to_fit();
        body.shrink_to_fit();
        redirects.shrink_to_fit();

        let until = match kind {
            LoopKind::While => false,
            LoopKind::Until => true,
        };

        Ok(Command::Compound(Box::new(CompoundCommand::Loop(until, guard, body)), redirects))
    }

    fn if_command(&mut self,
                  mut branches: Vec<(Vec<Self::Output>, Vec<Self::Output>)>,
                  mut else_part: Option<Vec<Self::Output>>,
                  mut redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>
    {
        for &mut (ref mut guard, ref mut body) in branches.iter_mut() {
            guard.shrink_to_fit();
            body.shrink_to_fit();
        }

        for els in else_part.iter_mut() { els.shrink_to_fit(); }
        redirects.shrink_to_fit();

        Ok(Command::Compound(Box::new(CompoundCommand::If(branches, else_part)), redirects))
    }

    fn for_command(&mut self,
                   var: String,
                   mut in_words: Option<Vec<Word>>,
                   mut body: Vec<Self::Output>,
                   mut redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>
    {
        for word in in_words.iter_mut() { word.shrink_to_fit(); }
        body.shrink_to_fit();
        redirects.shrink_to_fit();
        Ok(Command::Compound(Box::new(CompoundCommand::For(var, in_words, body)), redirects))
    }

    fn case_command(&mut self,
                    word: Word,
                    mut arms: Vec<(Vec<Word>, Vec<Self::Output>)>,
                    mut redirects: Vec<Redirect>)
        -> Result<Self::Output, Self::Err>
    {
        for &mut (ref mut pats, ref mut cmds) in arms.iter_mut() {
            pats.shrink_to_fit();
            cmds.shrink_to_fit();
        }

        redirects.shrink_to_fit();
        Ok(Command::Compound(Box::new(CompoundCommand::Case(word, arms)), redirects))
    }

    fn function_declaration(&mut self,
                            name: String,
                            body: Self::Output)
        -> Result<Self::Output, Self::Err>
    {
        Ok(Command::Function(name, Box::new(body)))
    }
}

impl ::std::default::Default for CommandBuilder {
    fn default() -> CommandBuilder {
        CommandBuilder
    }
}
