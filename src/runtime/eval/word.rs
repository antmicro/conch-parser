//! A module which defines evaluating any kind of word.

use runtime::{Environment, Result, Run};
use runtime::eval::{Fields, TildeExpansion, WordEval, WordEvalConfig};
use std::convert::{From, Into};
use std::iter::{IntoIterator, Iterator};
use std::rc::Rc;
use syntax::ast::{ComplexWord, SimpleWord, TopLevelWord, Word};

impl<W: WordEval, C: Run> WordEval for SimpleWord<W, C> {
    fn eval_with_config(&self, env: &mut Environment, cfg: WordEvalConfig) -> Result<Fields> {
        let ret = match *self {
            SimpleWord::Literal(ref s) |
            SimpleWord::Escaped(ref s) => Fields::Single(Rc::new(s.clone())),

            SimpleWord::Star        => Fields::Single(Rc::new(String::from("*"))),
            SimpleWord::Question    => Fields::Single(Rc::new(String::from("?"))),
            SimpleWord::SquareOpen  => Fields::Single(Rc::new(String::from("["))),
            SimpleWord::SquareClose => Fields::Single(Rc::new(String::from("]"))),
            SimpleWord::Colon       => Fields::Single(Rc::new(String::from(":"))),

            SimpleWord::Tilde => match cfg.tilde_expansion {
                TildeExpansion::None => Fields::Single(Rc::new(String::from("~"))),
                TildeExpansion::All |
                TildeExpansion::First => {
                    // Note: even though we are expanding the equivalent of `$HOME`, a tilde
                    // expansion is NOT considered a parameter expansion, and therefore
                    // should not be subjected to field splitting.
                    env.var("HOME").map_or(Fields::Zero, |f| Fields::Single(f.clone()))
                },
            },

            SimpleWord::Subst(ref s) => try!(s.eval(env, cfg)),
            SimpleWord::Param(ref p) => p.eval(cfg.split_fields_further, env).unwrap_or(Fields::Zero),
        };

        Ok(ret)
    }
}

impl<W: WordEval, C: Run> WordEval for Word<W, C> {
    fn eval_with_config(&self, env: &mut Environment, cfg: WordEvalConfig) -> Result<Fields> {
        let ret = match *self {
            Word::Simple(ref s) => try!(s.eval_with_config(env, cfg)),
            Word::SingleQuoted(ref s) => Fields::Single(Rc::new(s.clone())),
            Word::DoubleQuoted(ref v) => {
                // Make sure we are NOT doing any tilde expanions for further field splitting
                let cfg = WordEvalConfig {
                    tilde_expansion: TildeExpansion::None,
                    split_fields_further: false,
                };

                let mut fields = Vec::new();
                let mut cur_field: Option<String> = None;

                macro_rules! append_to_cur_field {
                    ($rc:expr) => {
                        match cur_field {
                            Some(ref mut cur_field) => cur_field.push_str(&$rc),
                            None => cur_field = Some(Rc::try_unwrap($rc).unwrap_or_else(|rc| (&*rc).clone())),
                        }
                    }
                };

                for w in v.iter() {
                    match (try!(w.eval_with_config(env, cfg)), w) {
                        (Fields::Zero, _) => continue,
                        (Fields::Single(s), _) => append_to_cur_field!(s),
                        (f@Fields::Star(_), _) => append_to_cur_field!(f.join_with_ifs(env)),

                        // Any fields generated by $@ must be maintained, however, the first and last
                        // fields of $@ should be concatenated to whatever comes before/after them.
                        (Fields::At(v), _) => {
                            // According to the POSIX spec, if $@ is empty it should generate NO fields
                            // even when within double quotes.
                            if !v.is_empty() {
                                let mut iter = v.into_iter();
                                if let Some(first) = iter.next() {
                                    append_to_cur_field!(first);
                                }

                                cur_field.take().map(|s| fields.push(Rc::new(s)));

                                let mut last = None;
                                for next in iter {
                                    fields.extend(last.take());
                                    last = Some(next);
                                }

                                last.map(|rc| append_to_cur_field!(rc));
                            }
                        },

                        // Since we should have indicated we do NOT want field splitting,
                        // the following word variants should all yield `Single` fields (or at least
                        // a specific `Star` or `At` field type for parameter{s, substitutions}).
                        (Fields::Split(_), &SimpleWord::Literal(_))  |
                        (Fields::Split(_), &SimpleWord::Escaped(_))  |
                        (Fields::Split(_), &SimpleWord::Star)        |
                        (Fields::Split(_), &SimpleWord::Question)    |
                        (Fields::Split(_), &SimpleWord::SquareOpen)  |
                        (Fields::Split(_), &SimpleWord::SquareClose) |
                        (Fields::Split(_), &SimpleWord::Tilde)       |
                        (Fields::Split(_), &SimpleWord::Colon)       |
                        (Fields::Split(_), &SimpleWord::Subst(_))    |
                        (Fields::Split(_), &SimpleWord::Param(_))    => unreachable!(),
                    }
                }

                cur_field.map(|s| fields.push(Rc::new(s)));
                fields.into()
            }
        };

        Ok(ret)
    }
}

impl<W: WordEval, C: Run> WordEval for ComplexWord<W, C> {
    fn eval_with_config(&self, env: &mut Environment, cfg: WordEvalConfig) -> Result<Fields> {
        let ret = match *self {
            ComplexWord::Single(ref w) => try!(w.eval_with_config(env, cfg)),

            ComplexWord::Concat(ref v) => {
                let cfg = WordEvalConfig {
                    tilde_expansion: TildeExpansion::None,
                    split_fields_further: cfg.split_fields_further,
                };

                let mut fields: Vec<Rc<String>> = Vec::new();
                for w in v.iter() {
                    let mut iter = try!(w.eval_with_config(env, cfg)).into_iter();
                    match (fields.pop(), iter.next()) {
                       (Some(last), Some(next)) => {
                           let mut new = Rc::try_unwrap(last).unwrap_or_else(|rc| {
                               let mut new = String::with_capacity(rc.len() + next.len());
                               new.push_str(&rc);
                               new
                           });
                           new.push_str(&next);
                           fields.push(Rc::new(new));
                       },
                       (Some(last), None) => fields.push(last),
                       (None, Some(next)) => fields.push(next),
                       (None, None)       => continue,
                    }

                    fields.extend(iter);
                }

                fields.into()
            },
        };

        Ok(ret)
    }
}

impl WordEval for TopLevelWord {
    fn eval_with_config(&self, env: &mut Environment, cfg: WordEvalConfig) -> Result<Fields> {
        self.0.eval_with_config(env, cfg)
    }
}

#[cfg(test)]
mod tests {
    use runtime::{Env, Environment, Result, RuntimeError};
    use runtime::ExpansionError::DivideByZero;
    use runtime::eval::{Fields, TildeExpansion, WordEval, WordEvalConfig};
    use std::rc::Rc;
    use syntax::ast::{Parameter, ParameterSubstitution, TopLevelWord};
    use syntax::ast::ComplexWord::*;
    use syntax::ast::SimpleWord::*;
    use syntax::ast::Word::*;
    use syntax::parse::test::lit;

    type SimpleWord  = ::syntax::ast::SimpleWord<TopLevelWord, MockCmd>;
    type ParamSubst  = ::syntax::ast::SimpleWord<TopLevelWord, MockCmd>;
    type Word        = ::syntax::ast::Word<SimpleWord, MockCmd>;
    type ComplexWord = ::syntax::ast::ComplexWord<Word, MockCmd>;

    #[derive(Copy, Clone, Debug)]
    struct MockCmd;
    impl ::runtime::Run for MockCmd {
        fn run(&self, _: &mut Environment) -> Result<::runtime::ExitStatus> {
            Ok(::runtime::EXIT_SUCCESS)
        }
    }

    #[test]
    fn test_simple_word_literal_eval() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let value = "foobar".to_owned();
        let simple: SimpleWord = Literal(value.clone());
        assert_eq!(simple.eval_with_config(&mut env, cfg), Ok(Fields::Single(value.into())));
    }

    #[test]
    fn test_simple_word_escaped_eval() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let value = "&& $@".to_owned();
        let simple: SimpleWord = Literal(value.clone());
        assert_eq!(simple.eval_with_config(&mut env, cfg), Ok(Fields::Single(value.into())));
    }

    #[test]
    fn test_simple_word_special_literals_eval_properly() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let cases: Vec<(SimpleWord, &'static str)> = vec!(
            (Star,        "*"),
            (Question,    "?"),
            (SquareOpen,  "["),
            (SquareClose, "]"),
            (Colon,       ":"),
        );

        let mut env = Env::new().unwrap();

        for (word, correct) in cases {
            let correct = Ok(Fields::Single(correct.to_owned().into()));
            assert_eq!(word.eval_with_config(&mut env, cfg), correct);
        }
    }

    #[test]
    fn test_word_lone_tilde_expansion() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::First,
            split_fields_further: true,
        };

        let home_value = Rc::new("foo bar".to_owned());
        let mut env = Env::new().unwrap();
        env.set_var("HOME".to_owned(), home_value.clone());

        let word: Word = Simple(Box::new(Tilde));
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(Fields::Single(home_value)));
    }

    #[test]
    fn test_simple_word_subst() {
        use syntax::ast::ParameterSubstitution;

        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::None,
            split_fields_further: false,
        };

        let var_name = "var".to_owned();
        let var_value = Rc::new("foo".to_owned());

        let mut env = Env::new().unwrap();
        env.set_var(var_name.clone(), var_value.clone());

        let simple: ParamSubst =
            Subst(Box::new(ParameterSubstitution::Len(Parameter::Var(var_name))));
        let correct = Fields::Single("3".to_owned().into());
        assert_eq!(simple.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_simple_word_subst_error() {
        use runtime::RuntimeError;
        use syntax::ast::{Arithmetic, ParameterSubstitution};

        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::None,
            split_fields_further: false,
        };

        let var_name = "var".to_owned();
        let var_value = Rc::new("foo".to_owned());

        let mut env = Env::new().unwrap();
        env.set_var(var_name.clone(), var_value.clone());

        let simple: ParamSubst = Subst(Box::new(ParameterSubstitution::Arith(Some(Arithmetic::Div(
            Box::new(Arithmetic::Literal(1)),
            Box::new(Arithmetic::Literal(0))
        )))));
        let correct = RuntimeError::Expansion(DivideByZero);
        assert_eq!(simple.eval_with_config(&mut env, cfg), Err(correct));
    }

    #[test]
    fn test_simple_word_param() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let var_name = "var".to_owned();
        let var_value = Rc::new("~/foo".to_owned());

        let mut env = Env::new().unwrap();
        env.set_var(var_name.clone(), var_value.clone());

        let simple: SimpleWord = Param(Parameter::Var(var_name));
        assert_eq!(simple.eval_with_config(&mut env, cfg), Ok(Fields::Single(var_value)));
    }

    #[test]
    fn test_simple_word_param_unset() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let simple: SimpleWord = Param(Parameter::Var("var".to_owned()));
        assert_eq!(simple.eval_with_config(&mut env, cfg), Ok(Fields::Zero));
    }

    #[test]
    fn test_simple_word_param_splitting() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All, // Should have no effect
            split_fields_further: true, // Should have effect
        };

        let var_name = "var".to_owned();
        let var_value = Rc::new("~ foo".to_owned());

        let mut env = Env::new().unwrap();
        env.set_var(var_name.clone(), var_value);

        let simple: SimpleWord = Param(Parameter::Var(var_name));
        let correct = Fields::Split(vec!("~".to_owned().into(), "foo".to_owned().into()));
        assert_eq!(simple.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_word_simple() {
        use syntax::ast::Arithmetic;

        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let value = "foo".to_owned();
        let word: Word = lit(&value);
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(Fields::Single(value.into())));

        let word: Word = Simple(Box::new(Subst(Box::new(ParameterSubstitution::Arith(Some(
            Arithmetic::Div(
                Box::new(Arithmetic::Literal(1)),
                Box::new(Arithmetic::Literal(0))
            )
        ))))));
        assert_eq!(word.eval_with_config(&mut env, cfg), Err(RuntimeError::Expansion(DivideByZero)));
    }

    #[test]
    fn test_word_single_quoted_should_not_split_fields_or_expand_anything() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let value = "~/hello world\nfoo\tbar *".to_owned();
        let word: Word = SingleQuoted(value.clone());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(Fields::Single(value.into())));
    }

    #[test]
    fn test_word_double_quoted_does_parameter_expansions_as_single_field() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let var = "var".to_owned();
        let mut env = Env::new().unwrap();
        env.set_var(var.clone(), "hello world".to_owned().into());

        let word: Word = DoubleQuoted(vec!(
            Literal("foo".to_owned()),
            Param(Parameter::Var(var)),
            Literal("bar".to_owned()),
        ));
        let correct = Fields::Single("foohello worldbar".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_word_double_quoted_does_not_expand_tilde() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let word: Word = DoubleQuoted(vec!(Tilde));
        let correct = Fields::Single("~".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));

        let word: Word = DoubleQuoted(vec!(Tilde, Literal("root".to_owned())));
        let correct = Fields::Single("~root".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));

        let word: Word = DoubleQuoted(vec!(Tilde, Literal("/root".to_owned())));
        let correct = Fields::Single("~/root".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_word_double_quoted_param_star_unset_results_in_no_fields() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let word: Word = DoubleQuoted(vec!(Param(Parameter::Star)));
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(Fields::Zero));
    }

    #[test]
    fn test_word_double_quoted_param_at_expands_when_args_set_and_concats_with_rest() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::with_config(false, None, Some(vec!(
            "one".to_owned(),
            "two".to_owned(),
            "three".to_owned(),
        )), None, None).unwrap();

        let word: Word = DoubleQuoted(vec!(
            Literal("foo".to_owned()),
            Param(Parameter::At),
            Literal("bar".to_owned()),
        ));

        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(Fields::Split(vec!(
            "fooone".to_owned().into(),
            "two".to_owned().into(),
            "threebar".to_owned().into(),
        ))));
    }

    #[test]
    fn test_word_double_quoted_param_at_expands_to_nothing_when_args_not_set_and_concats_with_rest() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let word: Word = DoubleQuoted(vec!(Param(Parameter::At)));
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(Fields::Zero));

        let word: Word = DoubleQuoted(vec!(
            Literal("foo".to_owned()),
            Param(Parameter::At),
            Literal("bar".to_owned()),
        ));
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok("foobar".to_owned().into()));
    }

    #[test]
    fn test_word_double_quoted_param_star_expands_but_joined_by_ifs() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::with_config(false, None, Some(vec!(
            "one".to_owned(),
            "two".to_owned(),
            "three".to_owned(),
        )), None, None).unwrap();

        let word: Word = DoubleQuoted(vec!(
            Literal("foo".to_owned()),
            Param(Parameter::Star),
            Literal("bar".to_owned()),
        ));

        // IFS initialized by environment for us
        let correct = Fields::Single("fooone two threebar".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));

        env.set_var("IFS".to_owned(), Rc::new("!".to_owned()));
        let correct = Fields::Single("fooone!two!threebar".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));

        env.set_var("IFS".to_owned(), "".to_owned().into());
        let correct = Fields::Single("fooonetwothreebar".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));

        env.unset_var("IFS".to_owned());
        let correct = Fields::Single("fooone two threebar".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_word_double_quoted_param_at_zero_fields_if_no_args() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let word: Word = DoubleQuoted(vec!(Param(Parameter::At)));
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(Fields::Zero));
    }

    #[test]
    fn test_word_double_quoted_no_field_splitting() {
        // Should have no effect
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        env.set_var("var".to_owned(), Rc::new("foo bar".to_owned()));

        let var = Parameter::Var("var".to_owned());

        let word: Word = DoubleQuoted(vec!(Param(var.clone())));
        let correct = Fields::Single("foo bar".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));

        let word: Word = DoubleQuoted(vec!(
            Subst(Box::new(ParameterSubstitution::Default(false, var, None)))
        ));
        let correct = Fields::Single("foo bar".to_owned().into());
        assert_eq!(word.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_complex_word_single() {
        use syntax::ast::Arithmetic;

        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let value = "foo".to_owned();
        let complex: ComplexWord = Single(Simple(Box::new(Literal(value.clone()))));
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(Fields::Single(value.into())));

        let complex: ComplexWord = Single(Simple(Box::new(Subst(Box::new(ParameterSubstitution::Arith(
            Some(Arithmetic::Div(
                Box::new(Arithmetic::Literal(1)),
                Box::new(Arithmetic::Literal(0))
            ))
        ))))));
        assert_eq!(complex.eval_with_config(&mut env, cfg), Err(RuntimeError::Expansion(DivideByZero)));
    }

    #[test]
    fn test_complex_word_concat_error() {
        use syntax::ast::Arithmetic;

        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let value = "foo".to_owned();
        let complex: ComplexWord = Single(Simple(Box::new(Literal(value.clone()))));
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(Fields::Single(value.into())));

        let complex: ComplexWord = Concat(vec!(
            Simple(Box::new(Subst(Box::new(ParameterSubstitution::Arith(
                Some(Arithmetic::Div(
                    Box::new(Arithmetic::Literal(1)),
                    Box::new(Arithmetic::Literal(0))
                ))
            )))))
        ));
        assert_eq!(complex.eval_with_config(&mut env, cfg), Err(RuntimeError::Expansion(DivideByZero)));
    }

    #[test]
    fn test_complex_word_concat_joins_all_inner_words() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        env.set_var("var".to_owned(), "foobar".to_owned().into());

        let complex: ComplexWord = Concat(vec!(lit("hello")));
        let correct = Fields::Single("hello".to_owned().into());
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(correct));

        let complex: ComplexWord = Concat(vec!(
            lit("hello"),
            Simple(Box::new(Param(Parameter::Var("var".to_owned())))),
            lit("world"),
        ));
        let correct = Fields::Single("hellofoobarworld".to_owned().into());
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_complex_word_concat_expands_to_many_fields_and_joins_with_those_before_and_after() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        env.set_var("var".to_owned(), "foo bar baz".to_owned().into());

        let complex: ComplexWord = Concat(vec!(
            lit("hello"),
            Simple(Box::new(Param(Parameter::Var("var".to_owned())))),
            lit("world"),
        ));

        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(Fields::Split(vec!(
            "hellofoo".to_owned().into(),
            "bar".to_owned().into(),
            "bazworld".to_owned().into(),
        ))));
    }

    #[test]
    fn test_complex_word_concat_should_not_expand_tilde_which_is_not_at_start() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All, // should have no effect
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let complex: ComplexWord = Concat(vec!(
            lit("foo"),
            Simple(Box::new(Tilde)),
            lit("bar"),
        ));
        let correct = Fields::Single("foo~bar".to_owned().into());
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(correct));

        let complex: ComplexWord = Concat(vec!(
            lit("foo"),
            Simple(Box::new(Tilde)),
        ));
        let correct = Fields::Single("foo~".to_owned().into());
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_complex_word_concat_empty_words_results_in_zero_field() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All, // should have no effect
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let complex: ComplexWord = Concat(vec!());
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(Fields::Zero));

        let var = Simple(Box::new(Param(Parameter::Var("var".to_owned()))));

        let complex: ComplexWord = Concat(vec!(var.clone()));
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(Fields::Zero));

        let complex: ComplexWord = Concat(vec!(var.clone(), var.clone()));
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(Fields::Zero));
    }

    #[test]
    fn test_complex_word_concat_param_at_expands_when_args_set() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All, // should have no effect
            split_fields_further: true,
        };

        let mut env = Env::with_config(false, None, Some(vec!(
            "one".to_owned(),
            "two".to_owned(),
            "three four".to_owned(),
        )), None, None).unwrap();

        let complex: ComplexWord = Concat(vec!(Simple(Box::new(Param(Parameter::At)))));
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(Fields::Split(vec!(
            "one".to_owned().into(),
            "two".to_owned().into(),
            "three".to_owned().into(),
            "four".to_owned().into(),
        ))));
    }

    #[test]
    fn test_complex_word_concat_param_at_expands_when_args_set_and_concats_with_rest() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All, // should have no effect
            split_fields_further: true,
        };

        let mut env = Env::with_config(false, None, Some(vec!(
            "one".to_owned(),
            "two".to_owned(),
            "three four".to_owned(),
        )), None, None).unwrap();

        let complex: ComplexWord = Concat(vec!(
            lit("foo"),
            Simple(Box::new(Param(Parameter::At))),
            lit("bar"),
        ));
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(Fields::Split(vec!(
            "fooone".to_owned().into(),
            "two".to_owned().into(),
            "three".to_owned().into(),
            "fourbar".to_owned().into(),
        ))));
    }

    #[test]
    fn test_complex_word_concat_param_at_expands_to_nothing_when_args_not_set_and_concats_with_rest() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All, // should have no effect
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let complex: ComplexWord = Concat(vec!(
            lit("foo"),
            Simple(Box::new(Param(Parameter::At))),
            lit("bar"),
        ));

        let correct = Fields::Single("foobar".to_owned().into());
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_complex_word_tilde_in_middle_of_word_after_colon_does_not_expand() {
        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All, // should have no effect
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let complex: ComplexWord = Concat(vec!(
            lit("foo"),
            Simple(Box::new(Colon)),
            Simple(Box::new(Tilde)),
            lit("bar"),
        ));

        let correct = Fields::Single("foo:~bar".to_owned().into());
        assert_eq!(complex.eval_with_config(&mut env, cfg), Ok(correct));
    }

    #[test]
    fn test_top_level_word() {
        use syntax::ast::Arithmetic;

        let cfg = WordEvalConfig {
            tilde_expansion: TildeExpansion::All,
            split_fields_further: true,
        };

        let mut env = Env::new().unwrap();
        let value = "foo".to_owned();
        let top_level_word = TopLevelWord(Single(Simple(Box::new(Literal(value.clone())))));
        assert_eq!(top_level_word.eval_with_config(&mut env, cfg), Ok(Fields::Single(value.into())));

        let top_level_word = TopLevelWord(Single(Simple(Box::new(Subst(Box::new(
            ParameterSubstitution::Arith(Some(Arithmetic::Div(
                Box::new(Arithmetic::Literal(1)),
                Box::new(Arithmetic::Literal(0))
            )))
        ))))));
        assert_eq!(top_level_word.eval_with_config(&mut env, cfg), Err(RuntimeError::Expansion(DivideByZero)));
    }
}
